# 进程与线程

**进程是操作系统资源分配的基本单位**，是程序运行的实例。例如打开一个浏览器就开启了一个进程。

**线程是操作系统调度到CPU中执行的基本单位**。例如在浏览器里新建一个窗口就需要一个线程来进行处理。

在一般情况下，线程是进程的组成部分，**一个进程可以包含多个线程**。例如浏览器可以新建多个窗口。

进程中的多个线程并发执行并**共享进程的内存**等资源。例如多个窗口之间可以共享登录状态、cookie等信息。

进程之间相对独立，不同进程具有不同的内存地址空间，系统资源描述符等。例如再新开一个浏览器，就又开启了一个进程，浏览器之间状态相互独立。

开启一个进程的开销比开启一个线程大得多，且**进程具有独立的内存空间**，多进程之间的通信通常比较困难。

# 并发与并行

并发不等于并行。

并发并不意味着同一时刻所有任务都在执行，而是在一个时间段内，所有的任务都能执行完毕。例如**在单核CPU上运行多线程程序，多线程会交替抢占CPU时间片**，任意一个时刻只能执行一个具体的线程。

**在多核CPU上，线程可以分布在多个CPU核心上运行，实现真正的并行处理。**

在多核处理场景中，并发与并行往往同时存在，多核心在并行处理多个线程，单核心中的多个线程又在交替执行。

# go协程与线程

线程是系统调度的基本单位。go协程由go语言运行时的调度器进行调度，操作系统内核感知不到协程的存在。

**在多核处理场景中，线程是并发与并行同时存在的，而go协程依托于线程，因此多核处理场景下，go协程也是并发与并行同时存在的**。因为go协程从属于某一个线程，所以即便在单核处理器上某一时刻运行一个线程，在线程内go语言调度器也会切换多个协程执行，这时协程是并发的。在多核心处理器上，如果多个协程被分配给了不同的线程，而这些线程同时被不同的CPU核心所处理，这时协程就是并行处理的。

go协程与线程存在着很多不同之处:

## 调度方式

**线程**: 线程是**根据CPU时间片进行抢占式调度**的。操作系统通过中断信号(定时器中断、I/O设备中断等)执行线程的上下文切换。当发生线程上下文切换时，需要从操作系统**用户态**转移到**内核态**，并保存状态信息；当切换到下一个要执行的线程时，需要加载状态信息并从内核态转移到操作系统用户态。

**协程**: 协程存在于**用户态**，由go语言**运行时调度器进行调度**。协程从属于某一个线程，多个协程可以调度到一个线程中，一个协程也可能切换到多个线程中执行，因此协程与线程是多对多(`M:N`)的关系。

## 调度策略

**线程**: **抢占式调度**。操作系统调度器为了均衡每个线程的执行周期，会定时发出中断信号强制执行线程上下文切换。

**协程**: **协作式调度**。一个协程处理完自己的任务后，可以主动将执行权限让渡给其他协程，不会被轻易抢占。只有在协程运行了过长时间后，go语言调度器才会强制抢占其执行。

## 上下文切换速度

**线程**: 线程上下文的切换需要经过操作系统用户态与内核态的切换，切换速度大约为1～2微秒。

**协程**: 协程属于用户态轻量级的线程，协程的切换不需要经过用户态与内核态的切换，且切换时只需要保存极少的状态值，因此切换速度快数倍，大约为0.2微秒左右。(大约10倍于线程的切换速度)

## 栈的大小

**线程**: 线程的栈大小一般是在创建时指定的，linux及mac上默认的栈大小一般为8MB(可以通过`ulimit -s`查看)。2000个线程需要消耗16G虚拟内存。

**协程**: go协程栈大小默认为2KB, 16G虚拟内存可以创建800多万个协程。在实践中，经常可以看到存在成千上万的协程。

# GMP模型

协程(G)线程(M)逻辑处理器(P)模型描述了线程与协程的关系。在GMP模型中：

`G`代表go协程(`Goroutine`),`M`代表实际的线程，`P`代表逻辑处理器(`Process`)。go语言为了方便协程的调度与缓存，抽象出了逻辑处理器`P`。

在任一时刻，**一个逻辑处理器P可能在本地包含多个协程G，同时绑定一个线程M**。

需要注意的是，**一个协程G并不是固定绑定同一个逻辑处理器P的**，可能转移到其他逻辑处理器中。

**逻辑处理器P对应的线程M也是不固定的**，在某些时候可能转移到其他P中执行。

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/965393889a5a43eaa974c30d05af735b~tplv-k3u1fbpfcp-watermark.image?)